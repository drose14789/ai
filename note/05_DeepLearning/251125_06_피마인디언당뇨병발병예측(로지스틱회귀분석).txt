2. 모델 구성
model = Sequential()
#model.add(Dense(units=32, input_dim=8, #input_shape=(8,)
#               activation='relu')
model.add(Input(shape=(8,)))
model.add(Dense(units=32, activation='relu'))
model.add(Dense(units=16, activation='relu'))
model.add(Dense(units=1, activation='sigmoid'))
model.summary()

3. 학습과정 설정
#model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['binary_accuracy'])
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

4. 학습
%%time
hist = model.fit(X_train, y_train, # 훈련데이터셋(학습데이터셋)
                epochs=200,
                batch_size=310,
                #validation_data=(X_test, y_test), 검증데이터셋
                validation_split=0.1, # 검증데이터 비율(훈련데이터에서 10%를 검증용데이터로)
                verbose=0) # 로그 출력 X
hist.history.keys()

5. 모델 평가하기
- 학습과정 시각화하여 살펴보기
- 평가
- 교차표(혼동매트릭스, 성능평가지표) 그리기
# 학습과정 표시하기
import matplotlib.pyplot as plt
fig, loss_ax = plt.subplots(figsize=(10,6))
loss_ax.plot(hist.history['loss'], 'y', label='train_loss')
loss_ax.plot(hist.history['val_loss'], 'r', label='val_loss')
acc_ax = loss_ax.twinx() # loss_ax와 x축을 공유하는 acc_ax 생성
acc_ax.plot(hist.history['accuracy'], 'g', label='train_accuracy')
acc_ax.plot(hist.history['val_accuracy'], 'b', label='val_accuracy')
loss_ax.set_xlabel('epoch')
loss_ax.set_ylabel('loss')
acc_ax.set_ylabel('accuracy')
loss_ax.legend(bbox_to_anchor=(0.955, 0.7))
acc_ax.legend(loc='center right')
plt.show()
# 모델 평가
score = model.evaluate(X_test, y_test)
print("loss : {}, 정확도 : {:.2f}%".format(score[0], score[1]*100))
# 교차표(혼동매트릭스, 성능평가지표) 그리기 : 테스트셋의 실제값과 예측값
y_hat = (model.predict(X_test) > 0.5).astype(int)
y_test.shape, y_hat.shape # 실제값(1차원), 예측값(2차원)
TN=0; FP=0; FN=0; TP=0;
for y, h in zip(y_test, y_hat.reshape(-1)):
    #print(y, h)
    if y==0 and h==0:
        TN += 1 # TN갯수 하나 증가
    elif y==0 and h==1:
        FP += 1
    elif y==1 and h==0:
        FN += 1
    else:
        TP += 1
print(TN, FP)
print(FN, TP)
ctab = pd.crosstab(y_test, y_hat.reshape(-1)) # y_hat 1차원이 아니면 에러남
ctab.index.name = '실제값'
ctab.columns.name = '예측값'
ctab

pd.crosstab(y_test, #실제값
           y_hat.reshape(-1), #예측값
           rownames=['실제값'], # index이름
           colnames=['예측값']) # column이름 : 결과가 데이터 프레임인 교차표
from sklearn.metrics import confusion_matrix
confusion_matrix(y_test, y_hat) # y_hat.reshape(-1) 둘다 가능
# 결과가 numpy배열인 혼동행렬

6. 모델 사용(예측 저장)
X_test[0]
(model.predict([[2, 112, 86, 42, 160, 38.4, 0.246, 28]])>0.5).astype(int)
from tensorflow.keras.models import save_model, load_model
model.save('model/06_binary.h5')
save_model(model, 'model/06_binary.5')
model2 = load_model('model/06_binary.h5')
(model.predict([[2, 112, 86, 42, 160, 38.4, 0.246, 28]])>0.5).astype(int)